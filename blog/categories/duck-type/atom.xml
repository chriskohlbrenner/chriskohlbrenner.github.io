<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: Duck Type | CEK.io]]></title>
  <link href="http://cek.io/blog/categories/duck-type/atom.xml" rel="self"/>
  <link href="http://cek.io/"/>
  <updated>2017-08-17T18:15:21-04:00</updated>
  <id>http://cek.io/</id>
  <author>
    <name><![CDATA[Chris Eaves-Kohlbrenner]]></name>
    <email><![CDATA[c.kohlbrenner@gmail.com]]></email>
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[Polymorphism and Duck Typing (POODR: Chapter 5)]]></title>
    <link href="http://cek.io/blog/2014/05/02/poodr-ch-5/"/>
    <updated>2014-05-02T09:42:24-04:00</updated>
    <id>http://cek.io/blog/2014/05/02/poodr-ch-5</id>
    <content type="html"><![CDATA[<p><strong>Having recently graduated from the Flatiron School, I am working my way through programming-related reading, beginning with Sandi Metz&rsquo;s &ldquo;Practical Object-Oriented Design in Ruby&rdquo;. Click <a href="http://cek.io/blog/categories/poodr/">here for more posts about POODR</a>.</strong></p>

<p>My hope for this blog post is not to intimidate (as Sandi Metz suggests below), but to communicate the concepts of polymorphism and duck typing in Ruby, as Metz describes them in Chapter 5 of POODR.</p>

<p>{% blockquote Sandi Metz <a href="http://www.amazon.com/Practical-Object-Oriented-Design-Ruby-Addison-Wesley/dp/0321721330">http://www.amazon.com/Practical-Object-Oriented-Design-Ruby-Addison-Wesley/dp/0321721330</a>  &ldquo;Practical Object-Oriented Design in Ruby (95)&rdquo;  %}
The term &lsquo;polymorphism&rsquo; is commonly used in object-oriented programming
but its use in everyday speech is rare enough to warrant a definition. <strong>Polymorphism</strong> expresses a very specific concept and can be used,
depending on your inclinations, either to <strong>communicate or to intimidate</strong>.
Either way, it’s important to have a clear understanding of its meaning. First, a general definition: &lsquo;Morph&rsquo; is the Greek word for form, &lsquo;morphism&rsquo; is the state of having a form, and <strong>&lsquo;polymorphism&rsquo; is the state of having many forms</strong>. Biologists use this word. Darwin’s famous finches are polymorphic; a single species has many forms. [&hellip;] <strong>Polymorphism in OOP refers to the ability of many different objects to respond to the same message</strong>. Senders of the message need not care about the class of the receiver; receivers supply their own specific version of the behavior.
{% endblockquote %}
(Bolded emphases mine)</p>

<!--more-->


<p>A pretty simple definition for a somewhat complicated word. Polymorphism, the state of having many forms. Specifically, for our purposes in object-oriented programming, the ability of many different objects to respond to the same message. Let&rsquo;s flesh this out.</p>

<h3>An example: Metz's Bike Co. (i.e., what problems does duck typing solve?)</h3>


<p>Imagine a bicycle touring company looking to automate its process of booking trips. Each trip needs to be prepared by a mechanic (ensuring the bicycles are in working order), a trip coordinator (handling logistics, like food, for the trip), and a driver (ensuring the vehicle is ready to transport the trip participants). The code below (straight from POODR) is an example of how <u>not</u> to do this. But why?</p>

<p>{% include_code poodr_5_bad_example.rb %}</p>

<p>I&rsquo;ll let Metz explain what&rsquo;s wrong with this:</p>

<p>{% blockquote Sandi Metz <a href="http://www.amazon.com/Practical-Object-Oriented-Design-Ruby-Addison-Wesley/dp/0321721330">http://www.amazon.com/Practical-Object-Oriented-Design-Ruby-Addison-Wesley/dp/0321721330</a>  &ldquo;Practical Object-Oriented Design in Ruby (90)&rdquo;  %}
Count the number of new dependencies in the prepare method. It relies on specific classes, no others will do. It relies on the explicit names of those classes. It knows the names of the messages that each class understands, along with the arguments that those messages require. All of this knowledge increases risk; many distant changes will now have side effects on this code.</p>

<p>To make matters worse, this style of code propagates itself. When another new trip preparer appears, you, or the next person down the programming line, will add a new when branch to the case statement. Your application will accrue more and more methods like this, where the method knows many class names and sends a specific message based on class. The logical endpoint of this programming style is a stiff and inflexible application, where it eventually becomes easier to rewrite everything than to change anything.
{% endblockquote %}</p>

<p>A lot of negative consequences: class dependencies, risk of side effects for distant changes, propogation of this type of code, and ultimately a rigid application that requires a rewrite. This is where duck typing comes in. It can prevent all of those things.</p>

<h3>Solving these problems with duck typing (i.e., what is duck typing anyway?</h3>


<p>Duck typing is about defining objects by <strong>what they do</strong> instead of <strong>who they are</strong>. Think about Trip&rsquo;s <code>prepare</code> method&mdash;what does it do? Metz describes, &ldquo;the method serves a single purpose, its arguments arrive wishing to collaborate to accomplish a single goal. Every argument is here for the same reason and that reason is unrelated to the argument’s underlying class&rdquo; (90). It&rsquo;s not about the class of each argument, be it <code>Mechanic</code>, <code>TripCoordinator</code>, or <code>Driver</code>. If it walks like a duck and quacks like a duck, treat it like a duck (or, in this case, like a <code>Preparer</code>). Consider the example below:</p>

<p>{% include_code poodr_5_duck_type_example.rb %}</p>

<p>What&rsquo;s changed? <code>Trip</code>&rsquo;s <code>prepare</code> method and each other class' unique preparation methods (they&rsquo;ve all become <code>prepare_trip</code>). We&rsquo;ve effectively implemented a <code>Preparer</code> class, but it has no concrete existence; it exists only as a duck type. Now all objects that implement <code>prepare_trip</code> are <code>Preparers</code>.</p>

<p>Is this better? How? First of all, there&rsquo;s a certain symmetry and conciseness to it. We can all agree (or should, anyway) that&rsquo;s better. Second, though our first example was more concrete (and, thus, perhaps simpler to understand), we now have more extensible code. It&rsquo;s slightly more abstract, but changes to the code require us only to turn another object into a <code>Preparer</code>, rather than changing our original <code>prepare</code> method to include yet another class.</p>

<p>Understanding these tradeoffs can be difficult, and it boils down to a tension between concretion and abstraction. Metz explains that &ldquo;Concrete code is easy to understand but costly to extend. Abstract code may initially seem more obscure but, once understood, is far easier to change. Use of a duck type moves your code along the scale from more
concrete to more abstract, making the code easier to extend but casting a veil over the
underlying class of the duck&rdquo; (94).</p>

<h3>Recognizing Ducks</h3>


<p>This is all great, but how can we recognize ducks (and thus duck-type our objects) if it is, in fact, a difficult situation to recognize? Three common patterns can be replaced with ducks: (1) case statements that switch on class (this is what we saw in the original bad example), (2) <code>kind_of?</code> and <code>is_a?</code>, and (3) <code>responds_to?</code>. Each of these patterns deals with the object&rsquo;s behavior. If you find yourself using these patterns to check on an object&rsquo;s behavior, remember: if it behaves like a duck, treat it as such.</p>

<h3>Wrapping up</h3>


<p>Why did I introduce this post with a definition of polymorphism? Because duck typing is a reality of OOP <strong>only because</strong> OOP is polymorphic. Though duck typing is only one way to achieve polymorphism in Ruby (inheritance and behavior sharing with modules are others), it is a great example of it. Duck types leverage the ability of many Ruby objects to respond to the same message, which is the very definition of polymorphism.</p>
]]></content>
  </entry>
  
</feed>
