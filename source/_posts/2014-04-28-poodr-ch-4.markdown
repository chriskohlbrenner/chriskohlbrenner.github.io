---
layout: post
title: "Public and Private Interfaces (POODR: Chapter 4)"
date: 2014-04-28 10:28:38 -0400
comments: true
categories: POODR Ruby Rails Books
---
<strong>Having recently graduated from the Flatiron School, I am working my way through programming-related reading, beginning with Sandi Metz's "Practical Object-Oriented Design in Ruby". Click <a href="/blog/categories/POODR/">here for more posts about POODR</a>.</strong>

{% img center /images/poodr-figure-4-1.png %}
What you see above are two very different communication patterns. Metz describes them as follows:
{% blockquote "Practical Object-Oriented Design in Ruby" http://www.amazon.com/Practical-Object-Oriented-Design-Ruby-Addison-Wesley/dp/0321721330 { Page 60 } %}
In the first application, the messages have no apparent pattern. [...] In the second application, the messages have a clearly defined pattern. [...] The design issue in the first application is not necessarily a failure of dependency injection or single responsibility. Those techniques, while necessary, are not enough to prevent the construction of an application whose design causes you pain. The roots of this new problem lie not in what each class does but with what it reveals."
{% endblockquote %}

<!--more-->

Welcome to public and private interfaces. As Metz explains, we can separate out the methods that we expose and reveal (that is, the public interface) from those that we keep private (known as the--wait for it--private interface). A couple other definitions of public and private interfaces:
<table>
  <tr>
    <th><strong>Public Interfaces</strong></th>
    <th><strong>Private Interfaces</strong></th>
  </tr>
  <tr>
    <td>The methods that make up the public interface of your class comprise the face it presents to the world. They:
      <ul>
        <li>Reveal its primary responsibility</li>
        <li>Are expected to be invoked by others</li>
        <li>Will not change on a whim</li>
        <li>Are safe for others to depend on</li>
        <li>Are thoroughly documented in the tests</li>
      </ul>
    </td>
    <td>All other methods in the class are part of its private interface. They:
      <ul>
        <li>Handle implementation details</li>
        <li>Are not expected to be sent by other objects</li>
        <li>Can change for any reason whatsoever</li>
        <li>Are unsafe for others to depend on</li>
        <li>May not even be referenced in the tests</li>
      </ul>
    </td>
  </tr>
</table>

What does that actually mean? POODR provides a helpful example of a restaurant kitchen: a customer should simply order their meal and have it served to them--the menu constitutes the public interface--without needing to go behind-the-scenes into the kitchen.

Awesome. Let's look at a real life example: <a href="http://www.tendermessenger.com/">Tender</a> (Github repo <a href="https://github.com/AlexPatriquin/BitcoinMessenger">here</a>). The image below depicts the main interface for the user: she is given options of sending or requesting bitcoin, typing a message, and designating an amount. This is the user's "menu", her public interface, the graphic at right at the top of this post. Of course, there's a private interface as well, the kitchen to this menu, the interwoven left graphic.

How does this play out in code? Like this:
{% include_code tender_user.rb %}

Without getting into the details of each method, what this structure demonstrates is a public interface that exposes just the <code>send_bitcoin</code> and <code>request_bitcoin</code> methods. This is all the menu that the User needs. Of course, behind the scenes there are lots of private methods being called, to say nothing of the controller actions delegating those methods, but the user only needs these two.

It comes down to creating explicit interfaces. As Metz argues,
{% blockquote "Practical Object-Oriented Design in Ruby" http://www.amazon.com/Practical-Object-Oriented-Design-Ruby-Addison-Wesley/dp/0321721330 { Page 76 } %}
Your goal is to write code that works today, that can easily be reused, and that can be adapted for unexpected use in the future. Other people will invoke your methods; it is your obligation to communicate which ones are dependable.

Every time you create a class, declare its interfaces. Methods in the public
interface should<ul>
<li>Be explicitly identified as such</li>
<li>Be more about what than how</li>
<li>Have names that, insofar as you can anticipate, will not change</li>
<li>Take a hash as an options parameter</li>
{% endblockquote %}

The code in the User model above was my attempt to do these things and thus apply practical techniques of object-oriented design.