---
layout: post
title: "An introduction to redis"
date: 2014-05-06 21:54:09 -0400
comments: true
categories: Ruby Redis Data NoSQL CT
---
Redis, which got its name as a <strong>re</strong>mote <strong>di</strong>ctionary <strong>s</strong>erver, is a key-value data store that can be useful for temporary caching or as a NoSQL ('not only SQL') data store.

I recommend getting started with <a href="http://labs.alcacoop.it/doku.php?id=articles:redis_land">this post about Redis</a>. It's a little old, but covers some key use cases for Redis. In this post, I will provide an overview to get started with Redis.

{% img right /images/redis-server.png 300 %}
<h3>Installation</h3>
Install Redis using Homebrew by running <code>brew install redis</code> from the command line. Alternatively, complete download instructions can be found <a href="">here</a>.

Once installed, starting a Redis server is as simple as running <code>redis-server</code>. You'll know you have it working if you see some ASCII art like what's depicted on the right.

<!--more-->

<h3>Code example</h3>
You can view a full code example in <a href="https://github.com/chriskohlbrenner/learn-redis">this Github repo</a>. It's not really necessary to focus on the controller logic in sinatra_app.rb (it's there to provide a user interface). This example can be viewed in the browser by running <code>ruby redis_models.rb</code>, starting a Redis server (<code>redis-server</code>), and visiting <a href="http://localhost:4567/">port 4567</a>.

That said, we can look at the code without serving the example app. The snippet below gives a sense of some basics of Redis, which I'll walk through line-by-line.

We start with the <code>RedisClient</code> class. This class enables us to create a new instance of the Redis client, connected to localhost:6379, which is the default for Redis servers. (Notice when you run <code>redis-server</code> from the console that we read "of the Redis client, connected to <strong>localhost:6379</strong>"). Instantiating a Redis client is necessary to work with the Redis server, thus we need the class on lines 6-11.

Side note: what's happening in line 7 with <code>include Singleton</code> isn't terribly important at this point. Suffice it to say that the Singleton class is needed when it is necessary to have only one instance of the class. In this case, we need one and only one instance of Redis. The <code>super</code> keyword uses the <code>Redis</code> superclass' <code>initialize</code> method, which is written into the Redis gem.

So how is Redis being used? Notice some of the main keywords that are unique to Redis: <code>lpush</code>, <code>sadd</code>, and--two of the most fundamental ones--<code>set</code> and <code>get</code>, which we'll see in more detail. I give an overview of the others at the end of this post.

{% include_code redis_book.rb %}

<h3>Interacting in IRB</h3>
Before we get too bogged down in the code, let's try this from the command line. Everything I've covered up to this point can be done in IRB.
<ol>
  <li>In IRB:<br>
    <code>require redis</code><br>
    <code>redis = Redis.new(:host => 'localhost', :port => 6379)</code>
  </li>
  <li>In a separate terminal window:<br>
    <code>redis-server</code>
  </li>
  <li>Below we see some of Redis' magic in setting (Redis <code>SET</code>, aliased by the gem as <code>set</code>) and getting (Redis <code>GET</code>, aliased as <code>get</code>) key-value pairs. We first set a new key-value pair (key of "hello", value of "world"), then get it by getting that value (with key "hello"). Back in IRB:<br>
    <code>redis.set("hello", "world")</code><br>
    <code>redis.get("hello") #=> "world"</code><br>
  </li>
  <li>But what other data types can Redis use? Here we see a hash:<br>
    <code>redis.set(:and_a_hash?, {a:1,b:2,c:3})</code><br>
    <code>redis.get(:and_a_hash?) #=> "{a:1,b:2,c:3}"</code><br>
    Note: this returns a string, but can be evaluated: <code>eval("{a:1,b:2,c:3}")    #=> {a:1,b:2,c:3}</code>.
  </li>
  <li>
    Lists, sets, other data types? (http://redis.io/topics/data-types)
  </li> 
</ol>

<h3>Redis data types and commands</h3>
There are a number key Redis commands. Below, I define each (Redis.io has more information about <a href="http://redis.io/topics/data-types">data types</a> and <a href="http://redis.io/commands">commands</a>). Ruby syntax is each Redis command downcase.
<table>
<strong>Strings</strong>: Strings are the most basic kind of Redis value. Redis Strings are binary safe, this means that a Redis string can contain any kind of data, for instance a JPEG image or a serialized Ruby object.
  <tr>
    <th><u>Redis Command</u></th>
    <th>&nbsp&nbsp&nbsp&nbsp</th>
    <th><u>Command Definition</u></th>
  </tr>
  <tr>
    <td>SET</td>
    <td>&nbsp&nbsp&nbsp&nbsp</td>
    <td>Set the string value of a key</td>
  </tr>
  <tr>
    <td>GET</td>
    <td>&nbsp&nbsp&nbsp&nbsp</td>
    <td>Get the value of a key</td>
  </tr>
  <tr>
    <td>INCR</td>
    <td>&nbsp&nbsp&nbsp&nbsp</td>
    <td>Increment the integer value of a key by one</td>
  </tr>
  <tr>
    <td>DECR</td>
    <td>&nbsp&nbsp&nbsp&nbsp</td>
    <td>Decrement the integer value of a key by one</td>
  </tr>
  <tr>
    <td>INCRBY</td>
    <td>&nbsp&nbsp&nbsp&nbsp</td>
    <td>Increment the integer value of a key by the given amount</td>
  </tr>
  <tr>
    <td>APPEND</td>
    <td>&nbsp&nbsp&nbsp&nbsp</td>
    <td>Append a value to a key</td>
  </tr>
  <tr>
    <td>GETRANGE</td>
    <td>&nbsp&nbsp&nbsp&nbsp</td>
    <td>Get a substring of the string stored at a key</td>
  </tr>
  <tr>
    <td>SETRANGE</td>
    <td>&nbsp&nbsp&nbsp&nbsp</td>
    <td>Overwrite part of a string at key starting at the specified offset</td>
  </tr>
  <tr>
    <td>GETBIT</td>
    <td>&nbsp&nbsp&nbsp&nbsp</td>
    <td>Returns the bit value at offset in the string value stored at key</td>
  </tr>
  <tr>
    <td>SETBIT</td>
    <td>&nbsp&nbsp&nbsp&nbsp</td>
    <td>Sets or clears the bit at offset in the string value stored at key</td>
  </tr>
</table>
<table>
<br>
<strong>Lists</strong>: Redis Lists are simply lists of strings, sorted by insertion order. It is possible to add elements to a Redis List pushing new elements on the head (on the left) or on the tail (on the right) of the list.
  <tr>
    <th><u>Redis</u></th>
    <th>&nbsp&nbsp&nbsp&nbsp</th>
    <th><u>Command</u></th>
  </tr>
  <tr>
    <td>LPUSH</td>
    <td>&nbsp&nbsp&nbsp&nbsp</td>
    <td>Prepend one or multiple values to a list</td>
  </tr>
  <tr>
    <td>RPUSH</td>
    <td>&nbsp&nbsp&nbsp&nbsp</td>
    <td>Append one or multiple values to a list</td>
  </tr>
</table>
<table>
<br>
<strong>Sets ("S"...)</strong>: Redis Sets are an unordered collection of Strings. It is possible to add, remove, and test for existence of members in O(1) (constant time regardless of the number of elements contained inside the Set).
  <tr>
    <th><u>Redis</u></th>
    <th>&nbsp&nbsp&nbsp&nbsp</th>
    <th><u>Command</u></th>
  </tr>
  <tr>
    <td>SADD</td>
    <td>&nbsp&nbsp&nbsp&nbsp</td>
    <td>Add one or more members to a set</td>
  </tr>
  <tr>
    <td>SINTER</td>
    <td>&nbsp&nbsp&nbsp&nbsp</td>
    <td>Intersect multiple sets</td>
  </tr>
  <tr>
    <td>SPOP</td>
    <td>&nbsp&nbsp&nbsp&nbsp</td>
    <td>Remove and return a random member from a set</td>
  </tr>
  <tr>
    <td>SRANDMEMBER</td>
    <td>&nbsp&nbsp&nbsp&nbsp</td>
    <td>Get one or multiple random members from a set</td>
  </tr>
</table>
<br>
<table>
<strong>Sorted Sets ("Z"...)</strong>: Redis Sorted Sets are, similarly to Redis Sets, non repeating collections of Strings. The difference is that every member of a Sorted Set is associated with score, that is used in order to take the sorted set ordered, from the smallest to the greatest score. While members are unique, scores may be repeated.
  <tr>
    <tr>
    <th><u>Redis</u></th>
    <th>&nbsp&nbsp&nbsp&nbsp</th>
    <th><u>Command</u></th>
  </tr>
    <td>ZADD</td>
    <td>&nbsp&nbsp&nbsp&nbsp</td>
    <td>Add one or more members to a sorted set, or update its score if it already exists</td>
  </tr>
  <tr>
    <td>ZRANGE</td>
    <td>&nbsp&nbsp&nbsp&nbsp</td>
    <td>Return a range of members in a sorted set, by index</td>
  </tr>
  <tr>
    <td>ZRANK</td>
    <td>&nbsp&nbsp&nbsp&nbsp</td>
    <td>Determine the index of a member in a sorted set</td>
  </tr>
  <tr>
    <td>ZRANGEBYSCORE</td>
    <td>&nbsp&nbsp&nbsp&nbsp</td>
    <td>Return a range of members in a sorted set, by score</td>
  </tr>
</table>
<br>
<h3>Wrapping up</h3>
That's a quick intro to Redis. You can try Redis using Redis' own  <a href="http://try.redis.io/">"Try Redis" command line tutorial</a>, but I prefer setting it up in an application or IRB environment myself.